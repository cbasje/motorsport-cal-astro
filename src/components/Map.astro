---
import "maplibre-gl/dist/maplibre-gl.css";
import type { trpc } from "lib/trpc/client";

// type Marker = { lat?: number; lon?: number };
type Marker = Awaited<
    ReturnType<typeof trpc.circuits.getMapMarkers.query>
>[number];
interface Props {
    markers: Marker[];
}
const { markers } = Astro.props;

const latitude = 47.93769444;
const longitude = 0.22561111;
const zoom = 2;
// const tileLayer = "https://api.maptiler.com/maps/streets/style.json?key=" + import.meta.env.PUBLIC_MAP_API_KEY;
const tileLayer =
    "https://api.maptiler.com/maps/2f9c2ed9-3ffa-479d-9e82-620c2be256d9/style.json?key=" +
    process.env.PUBLIC_MAP_API_KEY;
// const tileLayer = "https://demotiles.maplibre.org/style.json";
---

<map-libre
    data-latitude={latitude}
    data-longitude={longitude}
    data-zoom={zoom}
    data-tiles={tileLayer}
    data-markers={JSON.stringify(markers)}
>
    <div id="map"></div>
    <script>
        import { Map, Popup } from "maplibre-gl";

        class MapLibre extends HTMLElement {
            constructor() {
                super();

                const latlng: [number, number] = [
                    Number(this.dataset.latitude),
                    Number(this.dataset.longitude),
                ];

                const map = new Map({
                    container: "map",
                    style: this.dataset.tiles ?? "",
                    // attributionControl: false,
                    center: latlng ?? [0, 0],
                    zoom: Number(this.dataset.zoom),
                });

                const loadImage = async (url: string, name: string) =>
                    new Promise((resolve, reject) => {
                        map.loadImage(url, (error, image) => {
                            if (error) reject(error);
                            if (image) map.addImage(name, image);
                        });
                    });
                const loadAllImages = async (series: string[]) => {
                    const seriesSet = new Set(series);

                    seriesSet.forEach(async (item) => {
                        if (item)
                            await loadImage(`icons/pin/${item}.png`, item);
                    });
                };

                map.on("load", () => {
                    const markers = JSON.parse(this.dataset.markers ?? "[]");

                    loadAllImages(
                        markers.map((m) =>
                            m.rounds.map((r) => r.series).join("-")
                        )
                    ).then(() => {
                        // Add a GeoJSON source
                        map.addSource("circuits", {
                            type: "geojson",
                            data: {
                                type: "FeatureCollection",
                                features: markers.map((m) => {
                                    const series = m.rounds.map(
                                        (r) => r.series
                                    );
                                    return {
                                        type: "Feature",
                                        geometry: {
                                            type: "Point",
                                            coordinates: [m.lon, m.lat],
                                        },
                                        properties: {
                                            description: `<h4>${
                                                m.title
                                            }</h4><p>${series.join(", ")}</p>`,
                                            icon: series.join("-"),
                                        },
                                    };
                                }),
                            },
                        });

                        // Add a symbol layer
                        map.addLayer({
                            id: "circuits",
                            type: "symbol",
                            source: "circuits",
                            layout: {
                                "icon-image": "{icon}",
                                "icon-size": 0.5,
                                "icon-offset": [0, -16],
                                "icon-overlap": "always",
                            },
                        });

                        // When a click event occurs on a feature in the circuits layer, open a popup at the
                        // location of the feature, with description HTML from its properties.
                        map.on("click", "circuits", (e) => {
                            const coordinates =
                                e.features[0].geometry.coordinates.slice();
                            const description =
                                e.features[0].properties.description;

                            // Ensure that if the map is zoomed out such that multiple
                            // copies of the feature are visible, the popup appears
                            // over the copy being pointed to.
                            while (
                                Math.abs(e.lngLat.lng - coordinates[0]) > 180
                            ) {
                                coordinates[0] +=
                                    e.lngLat.lng > coordinates[0] ? 360 : -360;
                            }

                            new Popup()
                                .setLngLat(coordinates)
                                .setHTML(description)
                                .addTo(map);
                        });

                        // Change the cursor to a pointer when the mouse is over the circuits layer.
                        map.on("mouseenter", "circuits", () => {
                            map.getCanvas().style.cursor = "pointer";
                        });

                        // Change it back to a pointer when it leaves.
                        map.on("mouseleave", "circuits", () => {
                            map.getCanvas().style.cursor = "";
                        });
                    });
                });
            }
        }

        customElements.define("map-libre", MapLibre);
    </script>
</map-libre>

<style lang="scss">
    :global(main:has(#map)) {
        position: fixed;
        inset: 0;
        max-inline-size: unset;
        padding: 0;
    }

    map-libre,
    #map {
        width: 100%;
        height: 100%;
    }

    #map {
        :global(.maplibregl-popup-anchor-right .maplibregl-popup-tip) {
            border-left-color: var(--surface-1);
        }
        :global(.maplibregl-popup-anchor-bottom .maplibregl-popup-tip) {
            border-top-color: var(--surface-1);
        }
        :global(.maplibregl-popup-anchor-left .maplibregl-popup-tip) {
            border-right-color: var(--surface-1);
        }
        :global(.maplibregl-popup-anchor-top .maplibregl-popup-tip) {
            border-bottom-color: var(--surface-1);
        }
        :global(.maplibregl-popup-content) {
            background: var(--surface-1);
        }
    }
</style>
